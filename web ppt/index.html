<!doctype html>

<!--
  A presentation done entirely in Markdown, as found in extras/markdown/.
  
  By: @henrikingo
-->

<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Markdown in impress.js | by Henrik Ingo @henrikingo</title>
    
    <meta name="description" content="Authoring impress.js presentations in Markdown" />
    <meta name="author" content="Henrik Ingo" />
    <link rel="stylesheet" href="./css/github.css">

    <!-- Common styles for example presentations -->  
    <link href="./css/impress-common.css" rel="stylesheet" />  
    <!--
        Styles specific for this example presentation. 
    -->
    <link href="./css/markdown-slides.css" rel="stylesheet" />
    <link href="./css/devopsy.css" rel="stylesheet" />
    <link href="./css/effects.css" rel="stylesheet" />
    
</head>

<body class="impress-not-supported" style="background-color: #171717;">

<div id="impress" data-transition-duration="1000">

<div id="浅谈移动端适配方案" class="step slide markdown start">
# 浅谈移动端适配方案 

### — liam
</div>
<div id="前言" class="step slide markdown" data-rel-x="0" data-rel-y="900">
# 前言
### 有这么一群富有创造力与激情的年轻人
### 他们立志要把最好的互联网体验带给世界。
-----
### 他们有一个伟大的名字 
## —— *`前端工程师(QieTuZai)`*
![](images/qianduan.gif)
-----
### 他们主要的工作就是还原各种UI到终端上
### 他们的每一天都是充实而快乐的
![](images/gaoxiao.gif)
-----
### 好景不长
## 各种移动设备如雨后春笋般出现
## 而这直接影响到前端们的页面成果
![](images/cicun.png)
-----
### 所以，一场关于 
## HTML5页面如何在各种设备中“舒服”地展示
### 的战争悄然打响。
![](images/zhanzhen.jpg)
-----
# 几年过去了
### ...
-----
# 今天的前端工程师已经基本解决了所有适配问题
## 并且总结出了很多解决方案
- 手工适配
- 伸缩适配
- AI适配
- 黑白配
- 我不配
### ...
-----
### 但是，新了的问题也随之出现
![](images/sikao.jpg)
-----
### 适配方案万花齐放
# 很难形成有效的记忆
## 不知道每个方案之间的联系
### 更加无法定制自己的业务方案
-----
# 这些问题也深深困扰着我
#### 为了弄清这些方案背后的逻辑，我 “狠狠地”
![](images/xiong.jpg)
-----
# 去收集了一番资料
## 于是，就有了今天的分享
-----
# 听得懂，拿得走，用得上
## 分享后，你可以
- 对适配H5中用到的一些前端概念有了解
- 能辨别各种方案的优劣
- 根据业务场景定制自己的适配方案
</div>

<div id="标准" class="step slide markdown title-slide">
### 我们先讨论一个问题  
## 一套优秀的 H5适配方案 应该是怎么样的？
![](images/shipei.png)
-----
## 不能为每个设备都写一套适配规则
#### 最好能做到自动填满整个屏幕，不要留下空白，或者出现溢出滚动条。且画面协调，不变形。
-----
## 操作简单
## 系统不要对业务代码干扰过大，改造成本小。
-----
## 可以考虑到一些特殊设备
### 高分辨率下，可以显示得更加细腻
### 大屏幕下，可以看到更多内容
-----
### 于是，我们可以总结
# 一套好的方案需要满足的三点标准
- 自动适配屏幕
- 操作简单，业务无入侵
- 兼容高清
</div>


<div id="一些必要前置的适配知识点" class="step slide markdown" data-rotate="-85" data-x="2000" data-y="1000" data-z="1000" data-scale="4">
# 一些必要前置的适配知识点
### 总共涉及 6 个
- rem
- 视窗 viewport
- 视口单位	vw & vh
- 分辨率（像素）
- dpr （设备像素比）
- viewport meta
</div>
<div class="step slide markdown" data-rotate="-85" data-x="2000" data-y="6000" data-z="1000" data-scale="4">
# rem
一个相对尺寸单位。 html 元素的font-size = 1 rem 大小；
<br>
# 视窗 viewport
简单的理解，viewport等于浏览器的窗口。在桌面浏览器中，viewport的大小就是浏览器窗口的宽度和高度。
### clientWidth = document.documentElement.clientWidth
</div>
<div class="step slide markdown" data-rotate="-85" data-x="2000" data-y="10000" data-z="1000" data-scale="4">
# 视口单位	vw & vh
### 相对于视窗宽度的单位，1vw 等于屏幕宽度的 1%
### 相对于视窗高度的单位，1vh 等于屏幕高度的 1%
</div>
<div class="step slide markdown vw" data-rotate="-85" data-x="2000" data-y="14000" data-z="1000" data-scale="3">
![](images/vwvh.png)
</div>
<div class="step slide markdown" data-rotate="0" data-x="2000" data-y="18000" data-z="1000" data-scale="4">
# 分辨率（像素）
### 显示分辨率就是屏幕上显示的像素个数
# 物理像素 （物理分辨率）
### 就是真实排列在屏幕上的，实际的 LED 数；
</div>
<div class="step slide markdown vw" data-rotate="0" data-x="2000" data-y="22000" data-z="1000" data-scale="2">
![](images/iphone12.png)
</div>
<div class="step slide markdown" data-rotate="0" data-x="2000" data-y="25000" data-z="1000" data-scale="4">
# 逻辑像素 （逻辑分辨率，css 像素）
### 一个抽象的单位，css 的 1px 其实表示的就是 1 逻辑像素
### 而1px 可能由多个物理像素(LED)组成
![](images/led.png)
</div>
<div class="step slide markdown" data-rotate="85" data-x="2000" data-y="30000" data-z="1000" data-scale="5">
# dpr （设备像素比）
### devicePixelRatio，简称 dpr
表示当前显示设备的 物理像素分辨率 与 CSS 像素分辨率的 比率
<br>
# dpr ＝ 物理像素 / css像素
#### 一个 >1 的数字
</div>
<div class="step slide markdown big-code" data-rotate="85" data-x="2000" data-y="34000" data-z="2000" data-scale="3">
## 获取一个设备的dpr
<p>
          //js 中
          const dpr = window.devicePixelRatio

          //css 中
          -webkit-device-pixel-ratio;
          -webkit-min-device-pixel-ratio;
          -webkit-max-device-pixel-ratio
</p>
### 简单地说
## 这告诉浏览器应该使用多少个 LED 来显示一个 CSS像素
</div>
<div class="step slide markdown" data-rotate="85" data-x="2000" data-y="38000" data-z="1000" data-scale="4">
# viewport meta 标签
### 通过设置 viewport meta 标签可以告诉浏览器关于渲染的一些重要的信息： 
</div>
<div class="step slide markdown vw" data-rotate="85" data-x="2000" data-y="42000" data-z="1000" data-scale="4">
![](images/meta.png)
</div>
<div class="step slide markdown vw" data-rotate="85" data-x="-1000" data-y="42000" data-z="1000" data-scale="3">
# 其中比较重要的几个
- width
- initial-scale
- user-scalable
- viewport-fit （iphoneX 新增，渲染安全区域的方式）
</div>
<div class="step slide markdown vw" data-rotate="85" data-x="-3000" data-y="42000" data-z="1000" data-scale="2">
# 以上就是全部适配用到的知识点
## 接下来我们来分析业界的几种适配方案
</div>

<div id="方案的分类" class="step slide markdown" data-rotate="-85" data-x="4000" data-y="2000">
# 方案的分类
- 媒体查询  @media
- 动态设置 rem
- 动态设置 initial-scale
- vw & vh
</div>
<div id="媒体查询" class="step slide markdown" data-rotate="-85" data-x="5000" data-y="2000">
# 媒体查询 @meida
### 通过媒体查询，根据视窗的宽度，设置页面的对应的布局。
### 这是最原始的适配方案，就像web一样自然。
</div>
<div class="step slide markdown code" data-rotate="-85" data-x="6000" data-y="2000">
如果你希望自己的网页，一套兼容web 和 移动端，还是会用到 @meida 的知识；
<p>
          // 以下代码屏幕小于750px时，main 区域会占满屏幕，在750px- 1200px 时，会占比 70%
          @media screen and (min-width:750px) and (max-width:1200px){
            .main { width: 70% }
          }
          @media screen and (max-width:750px){
            .main { width: 100% }
          }
</p>
### 看demo @meida
</div>
<div class="step slide markdown code" data-rotate="-85" data-x="7000" data-y="2000">
# 特点
- 可以根据特定的需求，可以作出html 级别的展示调整
</div>
<div class="step slide markdown code" data-rotate="-85" data-x="8000" data-y="2000">
# 缺点
- 每个查询之间，存在边界情况，难以处理，无法做到自然过渡
- 同时需要写大量的css判断，写多套嵌套布局，修改繁琐
### 已经被大家所抛弃，这里不做深入探讨
</div>

<div class="step slide markdown" data-rotate="0" data-x="4000" data-y="5000">
# 动态设置 rem 方案
## 思路
1. 通过 meta 设置页面按视口1:1显示，不允许缩放，让页面表现得像原生app一样；
2. 用rem 作为换算单位，实现UI；
3. 监听视口宽度的改变，动态设置rem 的大小。通过 rem的相对单位属性。让UI实现自动改变大小以适配不同的视窗；
</div>
<div class="step slide markdown code" data-rotate="0" data-x="6000" data-y="5000">
# 设置meta
      meta 
      name=viewport 
      content="
        width=device-width,
        initial-scale=1,
        maximum-scale=1,
        user-scalable=no,
        viewport-fit=cover
      "
</div>
<div class="step slide markdown code" data-rotate="0" data-x="8000" data-y="5000">
# 设置监听函数
      resize(doc, win) {
        var docE1 = doc.documentElement,
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        recalc = function () {
          var clientWidth = docE1.clientWidth;
          if (!clientWidth) return;
          docE1.style.fontSize = (clientWidth / (375*2)) * 100 + 'px';    
        };
        if (!doc.addEventListener) return;
        win.addEventListener(resizeEvt, recalc, false);
        doc.addEventListener('DOMContentLoaded', recalc, false);
      },
</div>
<div class="step slide markdown code" data-rotate="0" data-x="10000" data-y="5000">
# body占满屏幕
        body {
          width: 7.5rem;
        }
### 看rem-demo
</div>
<div class="step slide markdown code" data-rotate="0" data-x="10000" data-y="6000">
# 特点
- 利用动态rem设置，已经做到了自动伸缩适配
## 但是细细观察，依然存在一些问题
</div>
<div class="step slide markdown code" data-rotate="0" data-x="10000" data-y="7000">
# 缺点
- 1px border 问题
- 屏幕很大时，一屏可以看到的内容没有更多
- 图片模糊
- 字体模糊
</div>
<div class="step slide markdown big-code" data-rotate="45" data-x="11000" data-y="5000" data-scale="5">
        docE1.style.fontSize = 
          (clientWidth / (375*2)) * 100 + 'px'
## 是怎么推导出来的？
## 为什么通过它可以做到刚刚好覆盖屏幕？
</div>
<div class="step slide markdown miao code" data-rotate="45" data-x="12000" data-y="5000">
- 推导  fontSize = (clientWidth / (375×2)) × 100 + 'px'
<br>
<p>假如现在我们有一个width 为 750px 的设计稿；</p>
<br>
<p>我们约定 1rem 表示 100px; </p>
<br>
<p>那么750px 的设计稿，UI 实现就是 7.5rem;</p>
<br>
<p>容易得到下面的代码：</p>
<br>
        body{
          width： 7.5rem； // 实际表现为 750px，1:1 还原设计稿
        }
</div>
<div class="step slide markdown miao code" data-rotate="45" data-x="13000" data-y="5000">
- *推导  fontSize = (clientWidth / (375×2)) × 100 + 'px'*
## 假如改变rem大小，现在 1rem = 80px
## 那么你就会得到什么？
</div>
<div class="step slide markdown miao code" data-rotate="45" data-x="14000" data-y="5000">
- *推导  fontSize = (clientWidth / (375×2)) × 100 + 'px'*
# 你会得到一份缩小20%的实现 
###（用rem 做单位的地方缩小）
        1rem = 80px
        body{
          width： 7.5rem； // 实际表现为 750* 0.8 = 600px，一个缩小了20%的body
        }
</div>
<div class="step slide markdown miao code" data-rotate="45" data-x="16000" data-y="5000">
- *推导  fontSize = (clientWidth / (375×2)) × 100 + 'px'*
### 根据 改变rem 就可以等比缩放UI实现的原理，我们只需要求出设计稿与实际屏幕的比例，就可以刚刚好放进去
<p>现在iphone6 的 clientWidth 是375，我们希望这份750px的UI实现适配iphone6</p>
<br>
<p>那么1rem 应该设置为多少px 呢？</p>
</div>
<div class="step slide markdown miao big-code" data-rotate="90" data-x="17000" data-y="5000">
- *推导  fontSize = (clientWidth / (375×2)) × 100 + 'px'*
### 只需要知道要缩小多少比例，就可以知道1rem 表示多少px，容易得到
          375 / 750 = fontSize / 100
### 转换:
          fontSize = (375/750) * 100
</div>
<div class="step slide markdown miao big-code" data-rotate="90" data-x="18000" data-y="5000">
- *推导  fontSize = (clientWidth / (375×2)) × 100 + 'px'*
### 因为375 是iphone6 的viewport 宽度
        fontSize = (375/750) * 100
### 进一步抽象可以得到
        fontSize = ( clientWidth / 750) * 100
</div>
<div class="step slide markdown miao big-code" data-rotate="90" data-x="18300" data-y="5000">
# 就这？
### 。。。
</div>
<div class="step slide markdown miao big-code" data-rotate="90" data-x="19500" data-y="5000">
## 当然不是!
### 这个方案只满足了我们的两个条件：
- 自动伸缩适配
- 实施简单
### 没有满足兼容高清屏幕
那么不满足高清屏幕，会带来什么问题吗？
</div>
<div class="step slide markdown miao big-code" data-rotate="90" data-x="20000" data-y="5000">
# 依然存在的问题 
- 1px border 问题
- 图片模糊
- 字体模糊
- 屏幕很大时，一屏可以看到的内容没有更多
</div>
<div class="step slide markdown miao" data-rotate="90" data-x="20000" data-y="6100">
# 什么是 1px border 问题？
### 其实就是1px的border，用了多个物理像素渲染。这样就会让1px border 显得有点粗
### 要解决这个问题，就需要了解一个概念 PPI
</div>
<div class="step slide markdown miao" data-rotate="90" data-x="20000" data-y="7200">
# PPI
### 表示每英寸物理像素个数
### 我们常常说的高清屏，实际就是PPI很高的屏幕；
![](images/PPI.png)
</div>
<div class="step slide markdown miao" data-rotate="90" data-x="20000" data-y="8300">
### 假定屏幕面积  1cm×1cm，普通屏有 100×100 个像素；你会得到这样一个表
![](images/mj.png)
</div>
<div class="step slide markdown miao" data-rotate="90" data-x="20000" data-y="9400">
### PPI 不同，获取到的 clientWidth 却是相同的
### 因为clientWidth是浏览器标准，PPI 是硬件标准
### 举个例子：
假如你现在有一台iphone6，原厂是 retina 屏幕，2倍屏；一天不小心你摔坏了屏幕，去换了一个普通屏(1:1)。
<br>
其实你们显示网页时，js 获取到的 document.documentElement.clientWidth 是一样的，都是375px；
<br>
css 设置，border：1px；
实际上 retina 屏会用 2px 去渲染 css 的1px；
这就导致了，1px border 看起来会有点粗。
</div>
<div class="step slide markdown miao" data-rotate="90" data-x="20000" data-y="10400">
## 理想的情况下，我们当然是希望即使是倍屏下，我们还是用物理1px 去显示 css 1 px；
### 那么应该怎么办呢？
</div>
<div class="step slide markdown code" data-rotate="90" data-x="19000" data-y="10400">
# 可以用以下几种方法解决：
- 0.5px

        border: 0.5px solid red;   //不是每个浏览器都能识别 0.5px
        <br>
- border-image 

        .pink-div{
          width: 100px;
          height: 100px;
          margin-top: 20px;
          border-bottom: 1px solid transparent;
          border-image: linear-gradient(to bottom, transparent 50%, red 50%) 0 0 100%/1px 0;
        }
</div>
<div class="step slide markdown code" data-rotate="90" data-x="18000" data-y="10400">
- box-shadow 

        .box-shadow-1px{
          box-shadow: 0px 0.5px 0px 0px #ee2c2c;
        }
        <br>
- scaleY(0.5)

        .border-bt-1px{
          position: relative;
          :before{
            content: '';
            position: absolute;
            left:0;           
            bottom: 0;
            width: 100%;
            height: 1px;
            background: #ee2c2c;
            transform: scaleY(0.5);
          }
        }
</div>
<div class="step slide markdown code" data-rotate="135" data-x="17000" data-y="10000">
# 图片，字体模糊的问题其实也是一样的
### 100×100 的图片，用了 200×200 的分辨率去渲染
### 正确的做法是 2倍屏 下就应该显示 @x2.jpg，让每一个物理像素(LED) 对应一个css像素
</div>
<div class="step slide markdown vw50 mt150" data-rotate="135" data-x="17000" data-y="11200">
![](images/2x.png) 
### 图片适配这里先卖个关子
</div>

<div id="flexiable" class="step slide markdown vw50" data-rotate="150" data-x="17000" data-y="12000">
### 第三种方案 
# 终于迎来今天分享的主角 flexiable.js 方案
### 经过手机淘宝双十一检验的方案
</div>
<div class="step slide markdown vw50" data-rotate="160" data-x="17000" data-y="12500">
# 实现思路
- flexible 其实也是基于rem 去实现UI
- 通过改变 initial-scale 的值去整体控制页面大小
- 约定把屏幕分为10份，每1份表示1rem
</div>
<div class="step slide markdown vw50" data-rotate="170" data-x="17000" data-y="13000">
# 优势
- 使用更加简单
- 天然解决 1px border 问题
- 以免去大量的重绘，也不会有rem 小数点导致的渲染不一样
- 大厂支持
</div>
<div class="step slide markdown vw50" data-rotate="180" data-x="17000" data-y="13500">
# 使用姿势
- 在index.html 中插入 flexiable.js;
- 量设计稿75px，在css 中写 1rem；
- 为了避免计算繁琐，可以安装vscode 插件 px2rem
</div>
<div class="step slide markdown vw50" data-rotate="190" data-x="17000" data-y="14000">
### 使用姿势
## 为了避免计算繁琐，可以安装vscode 插件 px2rem
  - 设置一下Root Font size 的大小，就可以帮助你自动计算出 rem，还可以控制保留多少位小数
</div>
<div class="step slide markdown vw80" data-rotate="200" data-x="17000" data-y="15000" data-scale="0.3">
![](images/px2rem.png)
</div>
<div class="step slide markdown vw80" data-rotate="200" data-x="17500" data-y="15000">
![](images/px2rem.gif)
</div>
<div class="step slide markdown code" data-rotate="210" data-x="17000" data-y="15500">
### 使用姿势
## webpack 插件 postcss-pxtorem，帮你自动转换代码 
<br>
        /* 安装 */
        npm install postcss-pxtorem -D
        /* 在webpack 中配置 */
        "postcss-pxtorem": {
          "rootValue": 75,
          "propList": ["*"],
          // 注意：如果有使用第三方UI如VUX，则需要配置下忽略选择器不转换。
          // 规则是class中包含的字符串，如vux中所有的class前缀都是weui-。也可以是正则。
          "selectorBlackList": ["weui-"]
        }
</div>
<div class="step slide markdown code" data-rotate="210" data-x="17000" data-y="16100">
### 使用姿势
- 那么你直接可以按着设计稿写代码。插件会自动帮你转为rem
<br>
          body {
            width: 750px;
          }
          
          //编译后
          body {
            widht: 23.4375rem;
          }
<br>
</div>

<div class="step slide markdown code" data-rotate="210" data-x="18000" data-y="16100">
- 上 demo
# 特点
- 不需要处理1px border问题
- 更大的屏幕可以看到更多的内容
</div>
<div class="step slide markdown code" data-rotate="210" data-x="17000" data-y="16500">
# 就这？
## ...
</div>
<div class="step slide markdown code" data-rotate="210" data-x="17000" data-y="17200">
# 就是这么简单
## 现在就只剩下下面两个问题了，而其实他们是同一个问题
  - 解决高清图片
  - 高清字体问题
## 并且flexiable 也提供了解决方案
</div>
<div class="step slide markdown code" data-rotate="220" data-x="17000" data-y="18000">
# 解决高清图片问题
- flexiable 已经根据 dpr 给html加上data-dpr了属性
## 只需要配合sass的宏函数，就可以自动适配高清图片
![](images/dpr.png)
</div>
<div class="step slide markdown code" data-rotate="220" data-x="17000" data-y="19000">
          @mixin background-url-dpr($picName) {
            background-image: url('xxx/quality,q_50/'+ $picName +',jpg');
            background-repeat: no-repeat;
            background-size: 100% 100%;
            [data-dpr="1"] & { 
              background-image: url('xxx/quality,q_50/'+ $picName +',jpg');
            } 
            [data-dpr="2"] & {
              background-image: url('xxx/quality,q_75/'+ $picName +',jpg');   
            } 
            [data-dpr="3"] & {
              background-image: url('xxx/quality,q_100/'+ $picName +',jpg');
            } 
          }

          .big-img {
            width: 5.333333rem /* 400/75 */;
            height: 4.8rem /* 360/75 */;
            @include background-url-dpr('$picName')
          }
</div>
<div class="step slide markdown code" data-rotate="220" data-x="17000" data-y="19900">
- 字体过粗其实也是一样的修复方案  
<dr>
          //定义                                     //使用
          @mixin font-size-dpr($fontSize) {         .dpr-font {
            font-size: $fontSize;                        @include font-size-dpr(16px) 
            [data-dpr="1"] & {                      }
              font-size: $fontSize;
            } 
            [data-dpr="2"] & {
                font-size: $fontSize * 2;
            } 
            [data-dpr="2.5"] & {
                font-size: $fontSize * 2;
            } 
            [data-dpr="2.75"] & {
                font-size: $fontSize * 2.2;
            } 
            [data-dpr="3"] & {
                font-size: $fontSize * 2.2;
            } 
          }
</div>
<div class="step slide markdown code" data-rotate="230" data-x="17000" data-y="21000">
# flexiable 方案已经完全具备了我们的要求
- 自动伸缩适应
- 实施简单
- 兼容高清
<dr></dr>
### 经过了双十一验证，大厂背书。
### 还可以让 ipad 设备能看到更多的内容。
## 建议把它作为自己H5适配的 “标准方案”。 
</div>
<div class="step slide markdown code" data-rotate="230" data-x="17000" data-y="21800">
# One more thing !
### flexiable 还为你考虑到了未来!
</div>
<div class="step slide markdown code" data-rotate="235" data-x="17000" data-y="22800">
# 业界未来的方案 —— vw 方案
业界最新的方案，其实就是使用 vw 代替 rem；
</div>
<div class="step slide markdown code" data-rotate="235" data-x="17000" data-y="23600">
## vw 天然把屏幕分为100份
### 前面说到flexiable 把屏幕分为10份，每份1rem，其实就是为了升级vw方案做的前置准备
## 容易得到 10vw = 1rem
</div>
<div class="step slide markdown code" data-rotate="235" data-x="17000" data-y="24400">
# 不再需要引入flexiable.js 库
          表示设计稿 75px 

          /*原来*/
          width: 1rem; 

          /* 现在 */
          width: 10vw
</div>
<div class="step slide markdown code" data-rotate="235" data-x="17000" data-y="25400">
# 可是~
## 你如果上vw，就需要自己解决其他问题
- 1px border
- 高清图片
- 高清字体
- 大屏适配
- 自己换算px to vw
- ...
</div>
<div class="step slide markdown code" data-rotate="245" data-x="18000" data-y="25400">
# flexiable 源码解读
### flexiable.js 的源码只有117行
### 我抽出几段重点跟大家看一下
</div>
<div class="step slide markdown code" data-rotate="245" data-x="18800" data-y="25400">
### 获取到设备的dpr，然后判断iphone是几倍屏，安卓默认一倍屏。
### 知道几倍屏后，缩放比就知道了， scale = 1 / dpr;
          var devicePixelRatio = win.devicePixelRatio;
          if (isIPhone) {
            // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案
            if (devicePixelRatio >= 3 && (!dpr || dpr >= 3)) {                
              dpr = 3;
            } else if (devicePixelRatio >= 2 && (!dpr || dpr >= 2)){
              dpr = 2;
            } else {
              dpr = 1;
            }
          } else {
            // 其他设备下，仍旧使用1倍的方案
            dpr = 1;
          }
          scale = 1 / dpr; //缩放比
</div>
<div class="step slide markdown code" data-rotate="245" data-x="19600" data-y="25400">
### 因为这个库诞生的时候，其实安卓机器普遍都是一倍屏
### 其实现在的安卓手机，屏幕也有很高的分辨率了，所以dpr 可以不用区分是否iphone
          if (devicePixelRatio >= 3 && (!dpr || dpr >= 3)) {                
            dpr = 3;
          } else if (devicePixelRatio >= 2 && (!dpr || dpr >= 2)){
            dpr = 2;
          } else {
            dpr = 1;
          }
          scale = 1 / dpr;
</div>
<div class="step slide markdown code" data-rotate="245" data-x="20400" data-y="25400">
### 通过设置initial-scale 就可以让页面整体缩放/放大，来适应新的视口
          metaEl.setAttribute('content', 
            'initial-scale=' + scale 
            + ', maximum-scale=' + scale 
            + ', minimum-scale=' + scale 
            + ', user-scalable=no'
          );
### 顺便解决字体模糊的问题
          doc.body.style.fontSize = 12 * dpr + 'px';
</div>
<div class="step slide markdown code" data-rotate="245" data-x="21200" data-y="25400">
## 怎么理解字体的适配？
### 因为正常页面的最小fontsize 只能是 12px，
### 所以我们把 12px * dpr，就可以得到倍屏下 的最小 fontsize；这样就解决了字体模糊的问题；
（注意这里不是设置html 的fontsize，跟rem 无关）
</div>
<div class="step slide markdown code" data-rotate="245" data-x="21200" data-y="26000">
## 上伸缩原理对比demo
- rem
- initial-scale
- transfrom
- zoom
</div>
<div class="step slide markdown code" data-rotate="255" data-x="21400" data-y="24000">
# 行业现状
## 没有最好，只有最适合
所以，其实现在各个大厂都是根据自己的业务去定制适配方案。有甚者，是为各种倍屏单独写一套css，例如:  今日头条。
有兴趣的可以看一下这个 [文章](https://juejin.cn/post/6844903693020758029#heading-7)
</div>
<div class="step slide markdown code" data-rotate="255" data-x="22400" data-y="24000">
# 方案对比
方案都大同小异，理解了几类方案的优缺点，灵活的组合他们，定制最适合自己业务场景的方案。
</div>
<div class="step slide markdown more" data-rotate="255" data-x="23400" data-y="24000">
![](images/duibi.png)
</div>

<div class="step slide markdown" data-rotate="270" data-x="23200" data-y="23000">
# 一道适配题
### 现在需要实现一个《618秒课》的H5页面
### 设计稿尺寸是 width（414×2）的2倍图（原型iphone11)
### 要求适配大部分移动设备（手机，ipad）。
</div>
<div class="step slide markdown" data-rotate="270" data-x="23200" data-y="21500" data-scale="0.5">
# 需求分析
### 这是一个购物网站
- 需要在更大的设备上，看到更多的信息
- 图片高清需求
- 414×2 宽度处理
- 其它需求（字体，布局变化等）
</div>
<div class="step slide markdown" data-rotate="270" data-x="23200" data-y="21000" data-scale="0.5">
# rem 方案
## fontSize/100 = clientWidth / 828
## fontSize = clientWidth / 828 × 100
### 其实就是求 本机 与 设计稿 的比例
</div>
<div class="step slide markdown" data-rotate="270" data-x="23800" data-y="21000" data-scale="0.5">
### 配置
## meta标签
## 1 border 高清 
## 图片高清 
## 字体高清
</div>
<div class="step slide markdown" data-rotate="270" data-x="23200" data-y="20000" data-scale="0.5">
# flexiable 方案
### 导入flexable.js
### 设置px2rem插件 
## 字体基数 =  414×2 / 10  *【十分之一屏幕】*
### 配合
- 图片高清
- 字体高清
</div>
<div class="step slide markdown" data-rotate="300" data-x="23200" data-y="18500" data-scale="2">
### 一些个人经验建议
## 纵向的单位，还是采用px开发
###（除非要求内容比例固定）
- 因为高度的超出可以滚动，不存在适配问题
- 当rem有很多小数点时，不同的设备，浏览器计算可能会有偏差，会导致元素上下重叠，覆盖。
</div>
<div class="step slide markdown" data-rotate="310" data-x="22800" data-y="17000" data-scale="3">
## 占满视窗 用 vw 代替 100%。
- 因为vw始终是相对于视窗的；100% 是相对于父盒子的。
</div>
<div class="step slide markdown" data-rotate="315" data-x="22000" data-y="16000" data-scale="3">
## 多实用flex布局
- 移动端基本都支持flex。
- 弹性布局本身就是为移动端开发而设计，具有一定自动伸缩特性。
</div>
<div class="step slide markdown" data-rotate="330" data-x="21000" data-y="13500" data-scale="5">
## 相对全面的方案
- 基于 flexiable 方案，满足安全，便捷开发。
- 加入sass 的字体，图片宏处理器 解决高清问题。
- 再适当配合 px，vw，vh，flex，以及开发时的 px2rem 插件处理大多数棘手问题。
</div>

<div id="overview" class="step markdown over" data-x="5000" data-y="4000" data-scale="10" style="pointer-events: none;" data-rotate="360">
## 我的分享已结束
# 谢谢大家
</div>

</div>

<div id="impress-toolbar"></div>
<!-- <div id="impress-help"></div> -->
<script type="text/javascript" src="./js/highlight.pack.js"></script>
<script type="text/javascript" src="./js/mermaid.min.js"></script>
<script type="text/javascript" src="./js/markdown.js"></script>
<script type="text/javascript" src="./js/impress.min.js"></script>
<script>impress().init();</script>
</body>
</html>
